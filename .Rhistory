#' The inverse gamma distribution with parameters \code{df = n} and \code{scale = s^2} has density
#'
#' \deqn{f(x)= (2^{-n/2}/Gamma(n/2)s^n x^(-n/2 - 1) e^(-n s^2/(2x)}
#'
#' for \eqn{x \ge 0}, \eqn{n > 0} and \eqn{s > 0}. (Here \eqn{Gamma(n/2)} is the function implemented by R's
#' \code{gamma()} and defined in its help. Note that \eqn{n = 0} corresponds to the trivial distribution with all mass at point 0.)
#'
#' The mean and variance are \eqn{E(X) = n/(n - 2) s^2} for \eqn{n > 2} and \eqn{Var(X) = 2n^2/(n-2)^2/(n-4) s^4} for \eqn{n>4}.
#'
#' The cumulative hazard \eqn{H(t) = - log(1 - F(t))} is
#' \code{-pinvgamma(t, ..., lower = FALSE, log = TRUE)}
#'
#' @inheritParams InvGammaDist
#' @return
#' \code{dinvchisq} gives the density, \code{pinvchisq} gives the distribution function,
#' \code{qinvchisq} gives the quantile function, and \code{rinvchisq}
#' generates random deviates.
#'
#' Invalid arguments will result in return value \code{NaN}, with a warning.
#'
#' The length of the result is determined by \code{n} for \code{rinvchisq},
#' and is the maximum of the lengths of the numerical arguments for the
#' other functions.
#'
#' The numerical arguments other than \code{n} are recycled to the length
#' of the result. Only the first elements of the logical arguments are used.
#' @export
#' @references Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari, A., & Rubin, D. B. (2013). Bayesian data analysis, 3rd edition. CRC press.
#' @rdname InvChisquare
#' @examples
#' x = 1:10
#' ## InvChisquare(df = n) is a special case of InvGamma(shape = n/2, scale = 1/2)
#' nu = 3
#' all.equal(dinvchisq(x, df = n), dinvgamma(x, shape = n/2, scale = 1/2))
#' all.equal(pinvchisq(x, df = n), pinvgamma(x, shape = n/2, scale = 1/2))
#'
#' ## InvChisquare(df = n, scale = s^2) is a special case of InvGamma(shape = n/2, scale = n/2 * s^2)
#' s = 1.7
#' all.equal(dinvchisq(x, df = n, scale = s^2), dinvgamma(x, shape = n/2, scale = n/2 * s^2))
#' all.equal(pinvchisq(x, df = n, scale = s^2), pinvgamma(x, shape = n/2, scale = n/2 * s^2))
#' @rdname InvChisquare
rinvchisq <- function(n, df, scale = 1/df) {
rinvgamma(n, shape = df/2, scale = df/2*scale)
}
#' @export
#' @rdname InvChisquare
dinvchisq <- function(x, df, scale = 1/df, log = FALSE) {
dinvgamma(x, shape = df/2, scale = df/2*scale, log = log)
}
#' @export
#' @rdname InvChisquare
pinvchisq <- function(q, df, scale = 1/df, lower.tail = TRUE, log.p = FALSE) {
pinvgamma(q, shape = df/2, scale = df/2*scale, lower.tail = lower.tail, log.p = log.p)
}
#' @export
#' @rdname InvChisquare
qinvchisq <- function(p, df, scale = 1/df, lower.tail = TRUE, log.p = FALSE) {
qinvgamma(p, shape = df/2, scale = df/2*scale, lower.tail = lower.tail, log.p = log.p)
}
x = 1:10
## InvChisquare(df = n) is a special case of InvGamma(shape = n/2, scale = 1/2)
nu = 3
all.equal(dinvchisq(x, df = n), dinvgamma(x, shape = n/2, scale = 1/2))
all.equal(pinvchisq(x, df = n), pinvgamma(x, shape = n/2, scale = 1/2))
## InvChisquare(df = n, scale = s^2) is a special case of InvGamma(shape = n/2, scale = n/2 * s^2)
s = 1.7
all.equal(dinvchisq(x, df = n, scale = s^2), dinvgamma(x, shape = n/2, scale = n/2 * s^2))
all.equal(pinvchisq(x, df = n, scale = s^2), pinvgamma(x, shape = n/2, scale = n/2 * s^2))
x = 1:10
## InvChisquare(df = n) is a special case of InvGamma(shape = n/2, scale = 1/2)
n = 3
all.equal(dinvchisq(x, df = n), dinvgamma(x, shape = n/2, scale = 1/2))
all.equal(pinvchisq(x, df = n), pinvgamma(x, shape = n/2, scale = 1/2))
## InvChisquare(df = n, scale = s^2) is a special case of InvGamma(shape = n/2, scale = n/2 * s^2)
s = 1.7
all.equal(dinvchisq(x, df = n, scale = s^2), dinvgamma(x, shape = n/2, scale = n/2 * s^2))
all.equal(pinvchisq(x, df = n, scale = s^2), pinvgamma(x, shape = n/2, scale = n/2 * s^2))
devtools::load_all(".")
devtools::load_all(".")
?rinvchisq
?dt
?dts
??dts
??pts
??rts
??qts
??dst
?invgamma
devtools::load_all(".")
?dinvchisq
?stats::Chisquare
?rt
?dnorm
?dst
?dt
?qst
?qt
brms::scaled_dt
brms::student_dt
brms::dstudent_t
?stop2
brms::pstudent_t
brms::qstudent_t
?brms::qstudent_t
#' The Scaled and Shifted Student t Distribution
#'
#' Density, distribution function, quantile function, and random generation for
#' the scaled and shifted t distribution with \code{df} degrees of freedom and
#' optional parameter \code{scale}. The parameterization is consistent with Gelman et al. (2013).
#'
#' If \code{mean} is omitted, it assumes the default value of \code{0}. If \code{sigma} is omitted, it assumes the default value of \code{1}.
#'
#' The scaled and shifted t distribution with parameters \code{df = n}, \code{mean =} \eqn{m} and \code{sigma =} \eqn{s} has density
#'
#' \deqn{f(x)= Gamma((n+1)/2)/Gamma(n/2)/\sqrt{n\pi}/s (1 + 1/n ((x - m)/s)^2)^{-(n+1)/2}}
#'
#' for \eqn{x \ge 0}, \eqn{n > 0} and \eqn{s > 0}. (Here \eqn{Gamma()} is the function implemented by R's
#' \code{gamma()} and defined in its help.
#'
#' The mean and variance are \eqn{E(X) = m} and \eqn{Var(X) = n/(n-2) s^2} for \eqn{n>2}.
#' @inheritParams rinvgamma
#' @return
#' \code{dst} gives the density, \code{pst} gives the distribution function,
#' \code{qst} gives the quantile function, and \code{rst}
#' generates random deviates.
#'
#' Invalid arguments will result in return value \code{NaN}, with a warning.
#'
#' The length of the result is determined by \code{n} for \code{rst},
#' and is the maximum of the lengths of the numerical arguments for the
#' other functions.
#'
#' The numerical arguments other than \code{n} are recycled to the length
#' of the result. Only the first elements of the logical arguments are used.
#' @export
#' @references Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari, A., & Rubin, D. B. (2013). Bayesian data analysis, 3rd edition. CRC press.
#' @name ScaledTDist
#' @examples
#' 1 - pt(1:5, df = 1, mean = 1, sigma = 1.2)
#' qst(.975, df = c(1:5), mean = 1:5, sigma = 1:5)
#' @rdname ScaledTDist
rinvchisq <- function(n, df, scale = 1/df) {
rinvgamma(n, shape = df/2, scale = df/2*scale)
}
#' @export
#' @rdname ScaledTDist
dst <- function(x, df, mean = 0, sigma = 1, log = FALSE) {
if (any(sigma) <= 0) {
stop("sigma must be positive")
}
if (!log) {
dt((x - mean)/sigma, df = df, log = log)/sigma
} else {
dt((x - mean)/sigma, df = df, log = log) - log(sigma)
}
}
#' @export
#' @rdname ScaledTDist
rst <- function(n, df, mean = 0, sigma = 1) {
if (any(sigma) <= 0) {
stop("sigma must be positive")
}
mean + sigma * rnorm(n) * sqrt(df/rchisq(n, df = df))
}
#' @export
#' @rdname ScaledTDist
qst <- function(p, df, mean = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE) {
if (sigma <= 0) {
stop("sigma must be positive")
}
mean + sigma * qt(p, df = df, lower.tail = TRUE, log.p = FALSE)
}
#' @export
#' @rdname ScaledTDist
pst <- function(q, df, mean = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE) {
if (any(sigma) <= 0) {
stop("sigma must be positive")
}
pt((q - mean)/sigma, df = df, lower.tail = lower.tail, log.p = log.p)
}
1 - pt(1:5, df = 1, mean = 1, sigma = 1.2)
qst(.975, df = c(1:5), mean = 1:5, sigma = 1:5)
1 - pst(1:5, df = 1, mean = 1, sigma = 1.2)
#' The Scaled and Shifted Student t Distribution
#'
#' Density, distribution function, quantile function, and random generation for
#' the scaled and shifted t distribution with \code{df} degrees of freedom and
#' optional parameter \code{scale}. The parameterization is consistent with Gelman et al. (2013).
#'
#' If \code{mean} is omitted, it assumes the default value of \code{0}. If \code{sigma} is omitted, it assumes the default value of \code{1}.
#'
#' The scaled and shifted t distribution with parameters \code{df = n}, \code{mean =} \eqn{m} and \code{sigma =} \eqn{s} has density
#'
#' \deqn{f(x)= Gamma((n+1)/2)/Gamma(n/2)/\sqrt{n\pi}/s (1 + 1/n ((x - m)/s)^2)^{-(n+1)/2}}
#'
#' for \eqn{x \ge 0}, \eqn{n > 0} and \eqn{s > 0}. (Here \eqn{Gamma()} is the function implemented by R's
#' \code{gamma()} and defined in its help.
#'
#' The mean and variance are \eqn{E(X) = m} and \eqn{Var(X) = n/(n-2) s^2} for \eqn{n>2}.
#' @inheritParams rinvgamma
#' @return
#' \code{dst} gives the density, \code{pst} gives the distribution function,
#' \code{qst} gives the quantile function, and \code{rst}
#' generates random deviates.
#'
#' Invalid arguments will result in return value \code{NaN}, with a warning.
#'
#' The length of the result is determined by \code{n} for \code{rst},
#' and is the maximum of the lengths of the numerical arguments for the
#' other functions.
#'
#' The numerical arguments other than \code{n} are recycled to the length
#' of the result. Only the first elements of the logical arguments are used.
#' @export
#' @references Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari, A., & Rubin, D. B. (2013). Bayesian data analysis, 3rd edition. CRC press.
#' @name ScaledTDist
#' @examples
#' 1 - pst(1:5, df = 1, mean = 1, sigma = 1.2)
#' qst(.975, df = c(1:5), mean = 1:5, sigma = 1:5)
#' @rdname ScaledTDist
rinvchisq <- function(n, df, scale = 1/df) {
rinvgamma(n, shape = df/2, scale = df/2*scale)
}
#' @export
#' @rdname ScaledTDist
dst <- function(x, df, mean = 0, sigma = 1, log = FALSE) {
if (any(sigma <= 0)) {
stop("sigma must be positive")
}
if (!log) {
dt((x - mean)/sigma, df = df, log = log)/sigma
} else {
dt((x - mean)/sigma, df = df, log = log) - log(sigma)
}
}
#' @export
#' @rdname ScaledTDist
rst <- function(n, df, mean = 0, sigma = 1) {
if (any(sigma <= 0)) {
stop("sigma must be positive")
}
mean + sigma * rnorm(n) * sqrt(df/rchisq(n, df = df))
}
#' @export
#' @rdname ScaledTDist
qst <- function(p, df, mean = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE) {
if (any(sigma <= 0)) {
stop("sigma must be positive")
}
mean + sigma * qt(p, df = df, lower.tail = TRUE, log.p = FALSE)
}
#' @export
#' @rdname ScaledTDist
pst <- function(q, df, mean = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE) {
if (any(sigma <= 0)) {
stop("sigma must be positive")
}
pt((q - mean)/sigma, df = df, lower.tail = lower.tail, log.p = log.p)
}
devtools::load_all(".")
?ScaledTDist
?dnorm
qnorm(0.6, log.p = FALSE)
qnorm(exp(0.6), log.p = TRUE)
qnorm(log(0.6), log.p = TRUE)
qnorm(0.6, log.p = FALSE)
qnorm(log(0.6), log.p = TRUE)
set.seed(8)
x = runif(50, 0, 10)
nu = runif(50, 0, 10)
scale = runif(50, 0, 10)
p = runif(50)
## test dst
# test rate argument works
da = brms::dt_scaled(x, nu, m, s)
set.seed(8)
x = runif(50, 0, 10)
nu = runif(50, 0, 10)
m = rnorm(50)
s = runif(50, 0, 10)
p = runif(50)
if (requireNamespace("brms", quietly = TRUE)) {
## test dst
# test rate argument works
da = brms::dt_scaled(x, nu, m, s)
db = dst(x, nu, m, s)
## test dst
# test rate argument works
da = brms::dt_scaled(x, nu, m, s)
set.seed(8)
x = runif(50, 0, 10)
nu = runif(50, 0, 10)
m = rnorm(50)
s = runif(50, 0, 10)
p = runif(50)
## test dst
# test rate argument works
da = brms::dt_scaled(x, nu, m, s)
## test dst
# test rate argument works
da = brms::dt_student(x, nu, m, s)
db = dst(x, nu, m, s)
set.seed(8)
x = runif(50, 0, 10)
nu = runif(50, 0, 10)
m = rnorm(50)
s = runif(50, 0, 10)
p = runif(50)
# if (requireNamespace("brms", quietly = TRUE)) {
## test dst
# test rate argument works
da = brms::dstudent_t(x, nu, m, s)
db = dst(x, nu, m, s)
all.equal(da, db)
## test dst
da = brms::dstudent_t(x, nu, m, s)
db = dst(x, nu, m, s)
log_da = brms::dstudent_t(x, nu, m, s, log = TRUE)
log_db = dst(x, nu, m, s, log = TRUE)
test_that("dst is correct", {
expect_true(all.equal(da, db))
expect_true(all.equal(log_da, log_db))
})
## test qst
qa = brms::qstudent_t(p, nu, m, s)
qb = qst(p, nu, m, s)
?brms::qstudent_t
## test qst
qa = brms::qstudent_t(p, nu, m, s)
qb = qst(p, nu, m, s)
ut_qa = brms::qstudent_t(p, nu, m, s, lower.tail = FALSE)
ut_qb = qst(p, nu, m, s, lower.tail = FALSE)
test_that("qst is correct", {
expect_equal(qa, qb)
expect_equal(ut_qa, ut_qb)
})
## test qst
qa = brms::qstudent_t(p, nu, m, s)
qb = qst(p, nu, m, s)
test_that("qst is correct", {
expect_equal(qa, qb)
})
## test pst
pa = brms::pstudent_t(x, nu, m, se)
pb = pst(x, nu, m, s)
logp_pa = brms::pstudent_t(x, nu, m, s, log.p = TRUE)
logp_pb = pst(x, nu, m, s, log.p = TRUE)
ut_pa = brms::pstudent_t(x, nu, m, s, lower.tail = TRUE)
ut_pb = pst(x, nu, m, s, lower.tail = TRUE)
ut_logp_pa = brms::pstudent_t(x, nu, scale = rate, lower.tail = TRUE, log.p = TRUE)
ut_logp_pb = pst(x, nu, rate = rate, lower.tail = TRUE, log.p = TRUE)
test_that("pst is correct", {
expect_equal(pa, pb)
expect_equal(log_pa, log_pb)
expect_equal(ut_pa, ut_pb)
expect_equal(ut_logp_pa, ut_logp_pb)
})
## test pst
pa = brms::pstudent_t(x, nu, m, se)
pb = pst(x, nu, m, s)
logp_pa = brms::pstudent_t(x, nu, m, s, log.p = TRUE)
logp_pb = pst(x, nu, m, s, log.p = TRUE)
ut_pa = brms::pstudent_t(x, nu, m, s, lower.tail = TRUE)
ut_pb = pst(x, nu, m, s, lower.tail = TRUE)
ut_logp_pa = brms::pstudent_t(x, nu, m, s, lower.tail = TRUE, log.p = TRUE)
ut_logp_pb = pst(x, nu, m, s, lower.tail = TRUE, log.p = TRUE)
test_that("pst is correct", {
expect_equal(pa, pb)
expect_equal(log_pa, log_pb)
expect_equal(ut_pa, ut_pb)
expect_equal(ut_logp_pa, ut_logp_pb)
})
## test rst
set.seed(1)
## test pst
pa = brms::pstudent_t(x, nu, m, s)
pb = pst(x, nu, m, s)
logp_pa = brms::pstudent_t(x, nu, m, s, log.p = TRUE)
logp_pb = pst(x, nu, m, s, log.p = TRUE)
ut_pa = brms::pstudent_t(x, nu, m, s, lower.tail = TRUE)
ut_pb = pst(x, nu, m, s, lower.tail = TRUE)
ut_logp_pa = brms::pstudent_t(x, nu, m, s, lower.tail = TRUE, log.p = TRUE)
ut_logp_pb = pst(x, nu, m, s, lower.tail = TRUE, log.p = TRUE)
test_that("pst is correct", {
expect_equal(pa, pb)
expect_equal(log_pa, log_pb)
expect_equal(ut_pa, ut_pb)
expect_equal(ut_logp_pa, ut_logp_pb)
})
## test pst
pa = brms::pstudent_t(x, nu, m, s)
pb = pst(x, nu, m, s)
logp_pa = brms::pstudent_t(x, nu, m, s, log.p = TRUE)
logp_pb = pst(x, nu, m, s, log.p = TRUE)
ut_pa = brms::pstudent_t(x, nu, m, s, lower.tail = TRUE)
ut_pb = pst(x, nu, m, s, lower.tail = TRUE)
ut_logp_pa = brms::pstudent_t(x, nu, m, s, lower.tail = TRUE, log.p = TRUE)
ut_logp_pb = pst(x, nu, m, s, lower.tail = TRUE, log.p = TRUE)
test_that("pst is correct", {
expect_equal(pa, pb)
expect_equal(logp_pa, logp_pb)
expect_equal(ut_pa, ut_pb)
expect_equal(ut_logp_pa, ut_logp_pb)
})
## test rst
set.seed(1)
r1 = brms::rstudent_t(50, nu, m, s)
set.seed(1)
r2 = rst(50, nu, m, s)
test_that("rst is correct", {
expect_equal(r1, r2)
})
?brms::rstudent_t
brms::rstudent_t
??invwish
Sigma = crossprod(rnorm(16), nrow = 4)
rinvwish(3, 2, Sigma)
rinvwish <- function(n, df, Sigma) {
x = rWishart(n, df, solve(Sigma))
xl = lapply(seq(dim(x)[3]), function(y) x[ , , y])
g = lapply(xl, solve)
g2 = array(unlist(g), dim = c(dim(g[[1]]), length(g)))
return(g2)
}
Sigma = crossprod(rnorm(16), nrow = 4)
rinvwish(3, 2, Sigma)
Sigma = crossprod(matrix(rnorm(16, nrow = 4))
rinvwish(3, 2, Sigma)
Sigma = crossprod(matrix(rnorm(16, nrow = 4)))
Sigma = crossprod(matrix(rnorm(16), nrow = 4))
rinvwish(3, 2, Sigma)
rinvwish(3, 4, Sigma)
?rWishart
rWishart(n, 1, solve(Sigma))
rWishart(1, 1, solve(Sigma))
rWishart(1, 1:4, solve(Sigma))
solve(Sigma)
?rnorm
?MASS::mvrnorm
Sigma = crossprod(matrix(rnorm(16), nrow = 4))
rinvwish(3, 4, Sigma)
y = rinvwish(3, 4, Sigma)
str(y)
?mvrnorm
#' v = matrix(c(10,3,3,2), 2, 2)Sigma
#' rmvnorm(n = 4, 1:2, v))
rmvnorm = function(n = 1, mu, v, method = "eigen") {
mu = as.vector(mu)
nr = length(mu)
# check argument validity
if(n < 0 || !is.finite(n))
{ stop("n should be a non-negative integer")}
if(!is.numeric(mu))
{ stop("mu must be a numeric vector")}
if(!is.matrix(v) || nrow(v)!=ncol(v) || !is.numeric(v))
{ stop("v must be a square numeric matrix")}
if(nr != nrow(v))
{ stop("length(mu)!=nrow(v)")}
if(!is.element(method, c("chol", "eigen", "svd")))
{ stop("method must be 'chol', 'eigen', or 'svd'")}
# return simulated values
mu + decomp_cov(v, method) %*% matrix(rnorm(nr * n), nrow = nr, ncol = n)
}
devtools::load_all(".")
devtools::load_all(".")
v = matrix(c(10,3,3,2), 2, 2)Sigma
rmvnorm(n = 4, 1:2, v))
rmvnorm(n = 4, 1:2, v)
v = matrix(c(10,3,3,2), 2, 2)Sigma
v = matrix(c(10,3,3,2), 2, 2)
rmvnorm(n = 4, 1:2, v)
rmvnorm(n = 4000, 1:2, v)
y = rmvnorm(n = 4000, 1:2, v)
rowMeans(y)
var(y)
var(t(y))
devtools::install_github("jfrench/bayesutils")
library(bayesutils)
set.seed(90)
#Set prior parameters
mu0 = 1.9
k0 = 1
nu0 = 1
sigma0 = 0.1
#define number of simulations, data, sample size, sample st dev, sample mean
B = 500000
y = c(1.64, 1.70, 1.72, 1.74, 1.82, 1.82, 1.82, 1.90, 2.08)
n = length(y)
s = sd(y)
ybar = mean(y)
#Initial value for sigma
sigma = sd(y)
#Initial value for mu
mu = mean(y)
#parameters for posterior
kn = k0 + n
mun = (k0 * mu0 + n * ybar) / kn
nun = nu0 + n + 1
sigmasqpost = numeric(B)
mupost = numeric(B)
for (i in 1:B) {
mu = rnorm(1, mun, sigma/sqrt(kn))
#parameter for full conditional posterior of sigma^2
ssqn = (nu0 * sigma0^2 + k0 * (mu - mu0)^2 + (n - 1) * s^2 + n * (ybar - mu)^2)/nun
sigmasq = rinvchisq(1, df = nun, scale = sqrt(ssqn))
sigma = sqrt(sigmasq)
mupost[i] = mu
sigmasqpost[i] = sigmasq
}
?dnorm
install.packages("brms")
install.packages("brms")
